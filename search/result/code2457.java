  if (!e.isInterruption()) { LOG.error(null, e);           }  return Status.OK_STATUS;         }  // wait for result  while (true) {  if (monitor != null && monitor.isCanceled()) {  return Status.OK_STATUS;           }  synchronized (m_result) {  if (m_result != null) {  break;             }  try {  m_result.wait(2000L);             }  catch (InterruptedException e) {  return Status.OK_STATUS;             }           }         }  if (monitor != null && monitor.isCanceled()) {  return Status.OK_STATUS;         }  if (m_result != null) {  new ClientSyncJob(AbstractCalendarItemProvider.this.getClass().getSimpleName() + " setItems", ClientSyncJob.getCurrentSession()) {  @Override  protected void runVoid(IProgressMonitor monitor2) throws Throwable {  setItemsInternal(m_loadingMinDate, m_loadingMaxDate, m_result);             }           }.schedule();         }  return Status.OK_STATUS;       }  finally {  // reset loading property in scout  new ClientSyncJob(AbstractCalendarItemProvider.this.getClass().getSimpleName() + " complete", ClientSyncJob.getCurrentSession()) {  @Override  protected void runVoid(IProgressMonitor monitor2) throws Throwable {  setLoadInProgress(false);           }         }.schedule();  // re-schedule  long n = getRefreshIntervalMillis();  if (n > 0 && m_minDateLoaded != null && m_maxDateLoaded != null) {  //m_minDateLoaded and m_maxDateLoaded might not have been set yet.  //-> Rescheduling (and cancelling currently running job) should only happen,  //   if previous job actually succeeded in loading the calendar items.  loadItemsAsyncInternal(ClientSyncJob.getCurrentSession(), m_minDateLoaded, m_maxDateLoaded, n);         }
